<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nora AI Assistant</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            text-align: center;
            padding: 20px 0;
            border-bottom: 1px solid #333;
        }

        header h1 {
            font-size: 2rem;
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        header p {
            color: #888;
            margin-top: 5px;
        }

        .status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 10px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ff4444;
        }

        .status-dot.connected {
            background: #00ff88;
            box-shadow: 0 0 10px #00ff88;
        }

        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .message {
            max-width: 80%;
            padding: 15px 20px;
            border-radius: 15px;
            line-height: 1.5;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.user {
            align-self: flex-end;
            background: linear-gradient(135deg, #0066ff, #0044cc);
            border-bottom-right-radius: 5px;
        }

        .message.assistant {
            align-self: flex-start;
            background: #2a2a4a;
            border-bottom-left-radius: 5px;
        }

        .message.system {
            align-self: center;
            background: transparent;
            color: #666;
            font-size: 0.9rem;
            padding: 10px;
        }

        .message.error {
            background: #442222;
            border: 1px solid #ff4444;
        }

        .typing-indicator {
            display: none;
            align-self: flex-start;
            padding: 15px 20px;
            background: #2a2a4a;
            border-radius: 15px;
        }

        .typing-indicator.active {
            display: flex;
            gap: 5px;
        }

        .typing-indicator span {
            width: 8px;
            height: 8px;
            background: #00d9ff;
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out;
        }

        .typing-indicator span:nth-child(1) { animation-delay: 0s; }
        .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
        .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes bounce {
            0%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
        }

        .input-container {
            display: flex;
            gap: 10px;
            padding: 20px 0;
            border-top: 1px solid #333;
        }

        #messageInput {
            flex: 1;
            padding: 15px 20px;
            border: none;
            border-radius: 25px;
            background: #2a2a4a;
            color: #e0e0e0;
            font-size: 1rem;
            outline: none;
            transition: box-shadow 0.3s;
        }

        #messageInput:focus {
            box-shadow: 0 0 0 2px #00d9ff;
        }

        #messageInput::placeholder {
            color: #666;
        }

        button {
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(135deg, #00d9ff, #00ff88);
            color: #1a1a2e;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0, 217, 255, 0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }

        .controls button {
            padding: 8px 16px;
            font-size: 0.85rem;
            background: #333;
            color: #e0e0e0;
        }

        .controls button:hover {
            background: #444;
        }

        /* Voice button */
        #voiceBtn {
            width: 50px;
            height: 50px;
            padding: 0;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #2a2a4a;
        }

        #voiceBtn:hover {
            background: #3a3a5a;
        }

        #voiceBtn.recording {
            background: linear-gradient(135deg, #ff4444, #ff6666);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(255, 68, 68, 0.4); }
            50% { box-shadow: 0 0 0 10px rgba(255, 68, 68, 0); }
        }

        #voiceBtn svg {
            width: 24px;
            height: 24px;
            fill: #e0e0e0;
        }

        /* Session info */
        .session-info {
            font-size: 0.8rem;
            color: #666;
            text-align: center;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1 id="headerTitle">ðŸ¤– Nora AI Assistant</h1>
            <p id="headerTagline">Your local AI companion</p>
            <div class="status">
                <span class="status-dot" id="statusDot"></span>
                <span id="statusText">Connecting...</span>
            </div>
            <div class="session-info" id="sessionInfo"></div>
            <div class="controls">
                <button onclick="newSession()">New Chat</button>
                <button onclick="downloadTranscript()">Download</button>
                <button onclick="clearChat()">Clear</button>
            </div>
        </header>

        <div class="chat-container" id="chatContainer">
            <div class="message system" id="welcomeMessage">
                Welcome! Type a message or click the microphone to speak.
            </div>
        </div>

        <div class="typing-indicator" id="typingIndicator">
            <span></span>
            <span></span>
            <span></span>
        </div>

        <div class="input-container">
            <button id="voiceBtn" onclick="toggleVoice()" title="Voice input">
                <svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm-1 1.93c-3.94-.49-7-3.85-7-7.93h2c0 3.31 2.69 6 6 6s6-2.69 6-6h2c0 4.08-3.06 7.44-7 7.93V19h4v2H8v-2h4v-3.07z"/></svg>
            </button>
            <input 
                type="text" 
                id="messageInput" 
                placeholder="Type your message..." 
                onkeypress="handleKeyPress(event)"
            >
            <button onclick="sendMessage()" id="sendBtn">Send</button>
        </div>
    </div>

    <script>
        // Configuration
        const WS_URL = `ws://${window.location.host}/ws`;
        const REST_URL = `/api/command`;
        const COMPANY_URL = `/api/company`;
        
        // State
        let ws = null;
        let clientId = localStorage.getItem('clientId') || generateId();
        let sessionId = null;
        let isRecording = false;
        let recognition = null;
        let companyConfig = {};

        // Save client ID
        localStorage.setItem('clientId', clientId);

        // Generate unique ID
        function generateId() {
            return 'web_' + Math.random().toString(36).substr(2, 8);
        }

        // Load company configuration
        async function loadCompanyConfig() {
            try {
                const response = await fetch(COMPANY_URL);
                if (response.ok) {
                    companyConfig = await response.json();
                    applyCompanyBranding();
                }
            } catch (error) {
                console.log('Using default branding');
            }
        }

        // Apply company branding to UI
        function applyCompanyBranding() {
            if (companyConfig.company_name) {
                document.title = `${companyConfig.assistant_name || 'AI'} - ${companyConfig.company_name}`;
            }
            if (companyConfig.assistant_name) {
                document.getElementById('headerTitle').textContent = 
                    `ðŸ¤– ${companyConfig.assistant_name} AI Assistant`;
            }
            if (companyConfig.tagline) {
                document.getElementById('headerTagline').textContent = companyConfig.tagline;
            }
            if (companyConfig.greeting) {
                document.getElementById('welcomeMessage').textContent = companyConfig.greeting;
            }
            if (companyConfig.primary_color) {
                document.documentElement.style.setProperty('--primary-color', companyConfig.primary_color);
            }
        }

        // Connect WebSocket
        function connect() {
            updateStatus('Connecting...', false);
            
            ws = new WebSocket(WS_URL);
            
            ws.onopen = () => {
                ws.send(JSON.stringify({
                    type: 'connect',
                    client_id: clientId,
                    session_id: sessionId
                }));
            };
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleMessage(data);
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateStatus('Connection error', false);
            };
            
            ws.onclose = () => {
                updateStatus('Disconnected', false);
                // Reconnect after 3 seconds
                setTimeout(connect, 3000);
            };
        }

        // Handle incoming messages
        function handleMessage(data) {
            switch (data.type) {
                case 'connected':
                    sessionId = data.session_id;
                    updateStatus('Connected', true);
                    updateSessionInfo();
                    break;
                    
                case 'response':
                    hideTyping();
                    addMessage(data.text, 'assistant');
                    // Speak the response
                    speak(data.text);
                    break;
                    
                case 'session_created':
                    sessionId = data.session_id;
                    updateSessionInfo();
                    addMessage('Started new conversation', 'system');
                    break;
                    
                case 'error':
                    hideTyping();
                    addMessage(data.message, 'error');
                    break;
                    
                case 'pong':
                    // Heartbeat response
                    break;
            }
        }

        // Send message
        function sendMessage() {
            const input = document.getElementById('messageInput');
            const text = input.value.trim();
            
            if (!text) return;
            
            addMessage(text, 'user');
            input.value = '';
            showTyping();
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'command',
                    text: text,
                    session_id: sessionId
                }));
            } else {
                // Fallback to REST
                sendRest(text);
            }
        }

        // Send via REST API
        async function sendRest(text) {
            try {
                const response = await fetch(REST_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: text,
                        client_id: clientId,
                        session_id: sessionId
                    })
                });
                
                const data = await response.json();
                hideTyping();
                
                if (data.success) {
                    sessionId = data.session_id;
                    updateSessionInfo();
                    addMessage(data.text, 'assistant');
                    speak(data.text);
                } else {
                    addMessage('Failed to get response', 'error');
                }
            } catch (error) {
                hideTyping();
                addMessage('Connection error: ' + error.message, 'error');
            }
        }

        // Add message to chat
        function addMessage(text, type) {
            const container = document.getElementById('chatContainer');
            const msg = document.createElement('div');
            msg.className = `message ${type}`;
            msg.textContent = text;
            container.appendChild(msg);
            container.scrollTop = container.scrollHeight;
        }

        // Show/hide typing indicator
        function showTyping() {
            document.getElementById('typingIndicator').classList.add('active');
        }

        function hideTyping() {
            document.getElementById('typingIndicator').classList.remove('active');
        }

        // Update status
        function updateStatus(text, connected) {
            document.getElementById('statusText').textContent = text;
            document.getElementById('statusDot').classList.toggle('connected', connected);
        }

        // Update session info
        function updateSessionInfo() {
            document.getElementById('sessionInfo').textContent = 
                sessionId ? `Session: ${sessionId}` : '';
        }

        // New session
        function newSession() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'new_session' }));
            }
        }

        // Clear chat
        function clearChat() {
            const container = document.getElementById('chatContainer');
            container.innerHTML = '<div class="message system">Chat cleared. Start a new conversation!</div>';
        }

        // Handle Enter key
        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        // Voice input
        function toggleVoice() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                alert('Voice input is not supported in your browser. Try Chrome.');
                return;
            }

            const btn = document.getElementById('voiceBtn');
            
            if (isRecording) {
                recognition.stop();
                btn.classList.remove('recording');
                isRecording = false;
            } else {
                recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                recognition.lang = 'en-US';
                recognition.continuous = false;
                recognition.interimResults = false;

                recognition.onstart = () => {
                    btn.classList.add('recording');
                    isRecording = true;
                };

                recognition.onresult = (event) => {
                    const text = event.results[0][0].transcript;
                    document.getElementById('messageInput').value = text;
                    sendMessage();
                };

                recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    btn.classList.remove('recording');
                    isRecording = false;
                };

                recognition.onend = () => {
                    btn.classList.remove('recording');
                    isRecording = false;
                };

                recognition.start();
            }
        }

        // Text-to-Speech
        function speak(text) {
            if ('speechSynthesis' in window) {
                // Cancel any ongoing speech
                speechSynthesis.cancel();
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 1.0;
                utterance.pitch = 1.0;
                utterance.volume = 1.0;
                speechSynthesis.speak(utterance);
            }
        }

        // Download transcript
        function downloadTranscript() {
            if (!sessionId) {
                alert('No conversation to download yet.');
                return;
            }
            
            // Open download in new tab/trigger download
            const url = `/api/conversations/${clientId}/${sessionId}/export?format=txt`;
            
            fetch(url)
                .then(response => response.text())
                .then(text => {
                    // Create download
                    const blob = new Blob([text], { type: 'text/plain' });
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = `transcript_${sessionId}.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(a.href);
                })
                .catch(error => {
                    console.error('Download failed:', error);
                    alert('Failed to download transcript.');
                });
        }

        // Heartbeat
        setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'ping' }));
            }
        }, 30000);

        // Initialize
        loadCompanyConfig();
        connect();
    </script>
</body>
</html>
